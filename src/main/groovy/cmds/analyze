#!/usr/bin/env groovy
package cmds

import org.apache.commons.csv.CSVFormat
import org.apache.commons.csv.CSVPrinter
import org.eclipse.jgit.api.Git

@Grapes([
        @Grab(group = 'org.eclipse.jgit', module = 'org.eclipse.jgit', version = '5.1.3.201810200350-r'),
        @Grab(group = 'org.apache.commons', module = 'commons-csv', version = '1.6')
])

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.concurrent.CompletableFuture

import static java.lang.System.err
import static java.util.concurrent.CompletableFuture.supplyAsync

def options = [
        '-p': { projects = (this.binding.variables.projects ?: []) + [it] },
        '-o': {
            file -> output = (file == '+' ? { System.out } : { prj -> new FileWriter("${file}/${prj.name}.csv") })
        }
]
def switches = [
        '--force': { forceClone = true }
]
args = args - args.findAll { it in switches.keySet() }.each { switches[it as String]?.call() }
args.findAll { it.matches('-?[^-].*') }.split { it.startsWith('-') }.transpose().each {
    option, arg -> options[option as String]?.call(arg)
}


if (!this.binding.variables.keySet().contains('output'))
    throw new RuntimeException("run configuration not set. Please use ${options.keySet()}")

def date(String d) {
    def gitFormat = DateTimeFormatter.ofPattern('yyy-MM-dd HH:mm:ss Z')
    LocalDateTime.parse(d, gitFormat)
}


def cloneRepo(String uri) {

    def dir = File.createTempDir()
    [
            git: Git.cloneRepository()
                    .setURI(uri)
                    .setRemote('origin')
                    .setBare(true)
                    .setDirectory(dir)
                    .setCloneAllBranches(true).call(),
            dir: dir
    ]
}

def analyzeRepo(def repo) {
    def repoDir = new File(repo.id as String)
    if (repoDir.listFiles()?.size() > 1) {

        File gitDir = new File("${repoDir.canonicalFile}/.git").with { exists() ? it : new File(it.parent) }
        err.println("\tAnalyzing $repo.name")
        def cli = "git --git-dir ${gitDir.canonicalFile} log --date=iso --all --pretty=format:%ad!!%an"
        [
                (repo.name): (cli.split(' ') as List).run()
        ]
    } else {
        [(repo.name): null]
    }

}

def processProject(def prj) {
    err.println(prj)
    def project = scm.getProject(prj)


    Set<Repository> repos = scm.getRepos(project.key).repos.collect {
        supplyAsync{
            it.tap { details = cloneRepo(it.clone.ssh) }
        }
    }.collect{ it.get()} as Set

    def results = repos.collect(this.&analyzeRepo)

    def (good, bad) = results.split { it.values().find { it?.code in (200..299) } }
    bad.collect { it.entrySet() }.flatten().each { err.format("\tBad repo %s: %s%n", it.key, it.value?.text ?: '') }

    return [
            name   : project.name,
            details: good.collectEntries { it }.collectEntries { k, v ->
                [
                        (k): v.text.split('\n')*.split('!!').collect { new Tuple2<>(date(it[0]), it[1]) }
                ]
            }.collect { k, v ->
                [
                        name         : k,
                        lastUpdated  : v*.first().max().toLocalDate(),
                        frequentUsers: v.take(10)*.second.countBy { it }
                                .sort { -it.value }.keySet().take(3)
                                *.replaceAll(~'(?:ST\\\\)?([a-zA-Z0-9]+)[\\\\. ]?([a-zA-Z]+)?[0-9]?', '$1 $2')

                ]
            }.sort { a, b -> b.lastUpdated <=> a.lastUpdated }
    ]
}

def writeCsv(def prj) {
    err.println("\tSaving results for ${prj.name}")
    CSVPrinter csv = prj.details*.frequentUsers.findAll().flatten().countBy { it }.sort { -it.value }
            .take(3)*.key.join(', ').with {
        new CSVPrinter(
                output.call(prj),
                CSVFormat.DEFAULT.withHeader("PROJECT (${it})", 'REPO', 'lastUpdated', 'Repo Contributors')
        )
    }
    prj.details.each {
        csv.printRecord(prj.name, it.name, it.lastUpdated ?: '', it.frequentUsers?.join(', ') ?: '')
    }

    csv.flush()
    csv.close()
}

if (this.binding.variables.projects) {
    projects.parallelStream().map { processProject(it) }.forEach { writeCsv(it) }
} else {
    scm.getProjects().parallelStream().map { processProject(it.key) }.forEach { writeCsv(it) }
}




