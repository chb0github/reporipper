#!/usr/bin/env groovy
package cmds

import org.apache.commons.csv.CSVFormat
import org.apache.commons.csv.CSVPrinter

@Grapes([
        @Grab(group = 'org.eclipse.jgit', module = 'org.eclipse.jgit', version = '5.1.3.201810200350-r'),
        @Grab(group = 'org.apache.commons', module = 'commons-csv', version = '1.6')
])

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

import static java.lang.String.format
import static java.lang.System.err

def options = [
        '-p': { projects = (this.binding.variables.projects ?: []) + [it] },
        '-o': {
            file -> output = (file == '+' ? { System.out } : { prj -> new FileWriter("${file}/${prj.name}.csv") })
        }
]
def switches = [
        '--force': { forceClone = true }
]
args = args - args.findAll { it in switches.keySet() }.each { switches[it as String]?.call() }
args.findAll { it.matches('-?[^-].*') }.split { it.startsWith('-') }.transpose().each {
    option, arg -> options[option as String]?.call(arg)
}


if (!this.binding.variables.keySet().contains('output'))
    throw new RuntimeException("run configuration not set. Please use ${options.keySet()}")

def date(String d) {
    def gitFormat = DateTimeFormatter.ofPattern('yyy-MM-dd HH:mm:ss Z')
    LocalDateTime.parse(d, gitFormat)
}


def cloneRepo(def repo) {

    if (!new File(repo.id as String).exists()) {
        if (!this.binding.variables.forceClone)
            throw new RuntimeException("Repo ${repo.name} does not exist but not allowed to clone")

        def git = format('git clone %s %s', repo.href, repo.id).tap { err.println("\t${it}") }

        git.run().tap { it.ok ?: err.println("\t${it.cli}: ${it.text}") }
    }
}

def analyzeRepo(def repo) {
    def repoDir = new File(repo.id as String)
    if (repoDir.listFiles()?.size() > 1) {

        File gitDir = new File("${repoDir.canonicalFile}/.git").with { exists() ? it : new File(it.parent) }
        err.println("\tAnalyzing $repo.name")
        def cli = "git --git-dir ${gitDir.canonicalFile} log --date=iso --all --pretty=format:%ad!!%an"
        [
                (repo.name): (cli.split(' ') as List).run()
        ]
    } else {
        [(repo.name): null]
    }

}

def processProject(def prj) {
    err.println(prj)
    def project = scm.getProject(prj).with {
        [
                name : it.key,
                repos: it.repos.values().collect {
                    [id: it.id, name: it.slug, href: it.links.clone.find { it.name == 'ssh' }?.href]
                }
        ]
    }

    project.repos.parallelStream().forEach(this.&cloneRepo)

    def results = project.repos.collect(this.&analyzeRepo)
    if (forceClone) {
        project.repos.split { new File(it.id as String).exists() && new File(it.id as String).deleteDir() }.tap {
            deleted, notDeleted ->
                deleted.each { err.println("\tDeleted ${it.name} ${it.id}") }
                notDeleted.each { err.println("\tUnable to delete ${it.name} ${it.id}") }
        }
    }



    def (good, bad) = results.split { it.values().find { it?.code in (200..299) } }
    bad.collect { it.entrySet() }.flatten().each { err.format("\tBad repo %s: %s%n", it.key, it.value?.text ?: '') }

    return [
            name   : project.name,
            details: good.collectEntries { it }.collectEntries { k, v ->
                [
                        (k): v.text.split('\n')*.split('!!').collect { new Tuple2<>(date(it[0]), it[1]) }
                ]
            }.collect { k, v ->
                [
                        name         : k,
                        lastUpdated  : v*.first().max().toLocalDate(),
                        frequentUsers: v.take(10)*.second.countBy { it }
                                .sort { -it.value }.keySet().take(3)
                                *.replaceAll(~'(?:ST\\\\)?([a-zA-Z0-9]+)[\\\\. ]?([a-zA-Z]+)?[0-9]?', '$1 $2')

                ]
            }.sort { a, b -> b.lastUpdated <=> a.lastUpdated }
    ]
}

def writeCsv(def prj) {
    err.println("\tSaving results for ${prj.name}")
    CSVPrinter csv = prj.details*.frequentUsers.findAll().flatten().countBy { it }.sort { -it.value }
            .take(3)*.key.join(', ').with {
        new CSVPrinter(
                output.call(prj),
                CSVFormat.DEFAULT.withHeader("PROJECT (${it})", 'REPO', 'lastUpdated', 'Repo Contributors')
        )
    }
    prj.details.each {
        csv.printRecord(prj.name, it.name, it.lastUpdated ?: '', it.frequentUsers?.join(', ') ?: '')
    }

    csv.flush()
    csv.close()
}

if (this.binding.variables.projects) {
    projects.parallelStream().map { processProject(it) }.forEach { writeCsv(it) }
} else {
    scm.getProjects().parallelStream().map { processProject(it.key) }.forEach { writeCsv(it) }
}




